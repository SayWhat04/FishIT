-- Migration: 20250424233900_initial_schema_setup.sql
-- Purpose: Initialize database schema for FlashCardz application
-- Tables: boxes, flashcards, tags, box_tags, generation_log
-- Author: System Generated

-- enable uuid extension
create extension if not exists "uuid-ossp";

-- enable citext extension for case-insensitive text
create extension if not exists "citext";

-- boxes table
create table public.boxes (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references auth.users(id),
  name text not null,
  description text,
  flashcard_count integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  is_deleted boolean not null default false
);

comment on table public.boxes is 'User flashcard boxes';
comment on column public.boxes.id is 'Unique identifier for the box';
comment on column public.boxes.user_id is 'User who owns the box';
comment on column public.boxes.name is 'Name of the box';
comment on column public.boxes.description is 'Optional description of the box';
comment on column public.boxes.flashcard_count is 'Counter of non-deleted flashcards in the box';
comment on column public.boxes.is_deleted is 'Soft delete flag';

-- flashcards table
create table public.flashcards (
  id uuid primary key default uuid_generate_v4(),
  box_id uuid not null references public.boxes(id),
  front text not null,
  back text not null,
  is_ai_generated boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  is_deleted boolean not null default false
);

comment on table public.flashcards is 'Flashcards for learning';
comment on column public.flashcards.id is 'Unique identifier for the flashcard';
comment on column public.flashcards.box_id is 'Box containing this flashcard';
comment on column public.flashcards.front is 'Question (front side of the flashcard)';
comment on column public.flashcards.back is 'Answer (back side of the flashcard)';
comment on column public.flashcards.is_ai_generated is 'Whether the flashcard was generated by AI';
comment on column public.flashcards.is_deleted is 'Soft delete flag';

-- tags table
create table public.tags (
  id uuid primary key default uuid_generate_v4(),
  name citext not null unique,
  created_at timestamptz not null default now()
);

comment on table public.tags is 'Tags for categorizing boxes';
comment on column public.tags.id is 'Unique identifier for the tag';
comment on column public.tags.name is 'Case-insensitive tag name';

-- box_tags junction table
create table public.box_tags (
  id uuid primary key default uuid_generate_v4(),
  box_id uuid not null references public.boxes(id),
  tag_id uuid not null references public.tags(id),
  created_at timestamptz not null default now()
);

comment on table public.box_tags is 'Junction table linking boxes to tags';
comment on column public.box_tags.id is 'Unique identifier for the box-tag relationship';
comment on column public.box_tags.box_id is 'Box ID reference';
comment on column public.box_tags.tag_id is 'Tag ID reference';

-- generation_log table
create table public.generation_log (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references auth.users(id),
  flashcard_id uuid references public.flashcards(id),
  original_front text not null,
  original_back text not null,
  status text not null check (status in ('accepted', 'rejected', 'edited')),
  generation_info jsonb,
  created_at timestamptz not null default now()
);

comment on table public.generation_log is 'Logs of AI-generated flashcards and user decisions';
comment on column public.generation_log.id is 'Unique identifier for the log entry';
comment on column public.generation_log.user_id is 'User who requested the generation';
comment on column public.generation_log.flashcard_id is 'Reference to the flashcard (null if rejected)';
comment on column public.generation_log.original_front is 'Original generated front text';
comment on column public.generation_log.original_back is 'Original generated back text';
comment on column public.generation_log.status is 'User decision status (accepted/rejected/edited)';
comment on column public.generation_log.generation_info is 'Additional generation metadata';

-- indexes
-- indexes for boxes table
create index idx_boxes_user_id on public.boxes(user_id);
create index idx_boxes_is_deleted on public.boxes(is_deleted);
create index idx_boxes_name on public.boxes(name) where is_deleted = false;

-- indexes for flashcards table
create index idx_flashcards_box_id on public.flashcards(box_id);
create index idx_flashcards_is_deleted on public.flashcards(is_deleted);
create index idx_flashcards_box_id_is_deleted on public.flashcards(box_id, is_deleted);

-- indexes for box_tags table
create index idx_box_tags_box_id on public.box_tags(box_id);
create index idx_box_tags_tag_id on public.box_tags(tag_id);
create unique index idx_box_tags_box_id_tag_id on public.box_tags(box_id, tag_id);

-- indexes for generation_log table
create index idx_generation_log_user_id on public.generation_log(user_id);
create index idx_generation_log_flashcard_id on public.generation_log(flashcard_id);
create index idx_generation_log_status on public.generation_log(status);

-- functions and triggers
-- function to update flashcard count
create or replace function update_flashcard_count()
returns trigger as $$
begin
  if tg_op = 'INSERT' then
    if new.is_deleted = false then
      update public.boxes
      set flashcard_count = flashcard_count + 1
      where id = new.box_id;
    end if;
  elsif tg_op = 'UPDATE' then
    if old.is_deleted = true and new.is_deleted = false then
      update public.boxes
      set flashcard_count = flashcard_count + 1
      where id = new.box_id;
    elsif old.is_deleted = false and new.is_deleted = true then
      update public.boxes
      set flashcard_count = flashcard_count - 1
      where id = new.box_id;
    elsif old.box_id <> new.box_id then
      if new.is_deleted = false then
        update public.boxes
        set flashcard_count = flashcard_count + 1
        where id = new.box_id;
      end if;
      if old.is_deleted = false then
        update public.boxes
        set flashcard_count = flashcard_count - 1
        where id = old.box_id;
      end if;
    end if;
  elsif tg_op = 'DELETE' then
    if old.is_deleted = false then
      update public.boxes
      set flashcard_count = flashcard_count - 1
      where id = old.box_id;
    end if;
  end if;
  return null;
end;
$$ language plpgsql;

comment on function update_flashcard_count() is 'Trigger function to keep flashcard_count in boxes table updated';

-- trigger for flashcard count updates
create trigger trg_flashcards_update_count
after insert or update or delete on public.flashcards
for each row execute function update_flashcard_count();

-- function to check box tags limit
create or replace function check_box_tags_limit()
returns trigger as $$
declare
  tag_count integer;
begin
  select count(*) into tag_count
  from public.box_tags
  where box_id = new.box_id;
  
  if tag_count >= 10 then
    raise exception 'Box cannot have more than 10 tags';
  end if;
  
  return new;
end;
$$ language plpgsql;

comment on function check_box_tags_limit() is 'Trigger function to limit the number of tags per box to 10';

-- trigger for box tags limit
create trigger trg_box_tags_limit
before insert on public.box_tags
for each row execute function check_box_tags_limit();

-- row level security setup
-- enable row level security on all tables
alter table public.boxes enable row level security;
alter table public.flashcards enable row level security;
alter table public.box_tags enable row level security;
alter table public.generation_log enable row level security;
alter table public.tags enable row level security;

-- rls policies for boxes
create policy "Users can view their own boxes"
  on public.boxes for select
  using (auth.uid() = user_id and is_deleted = false);

create policy "Users can insert their own boxes"
  on public.boxes for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own boxes"
  on public.boxes for update
  using (auth.uid() = user_id and is_deleted = false);

create policy "Users can soft delete their own boxes"
  on public.boxes for update
  using (auth.uid() = user_id)
  with check (is_deleted = true);

comment on policy "Users can view their own boxes" on public.boxes is 'Users can only view their own non-deleted boxes';
comment on policy "Users can insert their own boxes" on public.boxes is 'Users can only create boxes for themselves';
comment on policy "Users can update their own boxes" on public.boxes is 'Users can only update their own non-deleted boxes';
comment on policy "Users can soft delete their own boxes" on public.boxes is 'Users can only soft delete their own boxes';

-- rls policies for flashcards
create policy "Users can view flashcards in their boxes"
  on public.flashcards for select
  using (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.flashcards.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    ) and is_deleted = false
  );

create policy "Users can insert flashcards in their boxes"
  on public.flashcards for insert
  with check (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.flashcards.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    )
  );

create policy "Users can update flashcards in their boxes"
  on public.flashcards for update
  using (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.flashcards.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    ) and is_deleted = false
  );

create policy "Users can soft delete flashcards in their boxes"
  on public.flashcards for update
  using (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.flashcards.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    )
  ) with check (is_deleted = true);

comment on policy "Users can view flashcards in their boxes" on public.flashcards is 'Users can only view non-deleted flashcards in their non-deleted boxes';
comment on policy "Users can insert flashcards in their boxes" on public.flashcards is 'Users can only create flashcards in their non-deleted boxes';
comment on policy "Users can update flashcards in their boxes" on public.flashcards is 'Users can only update non-deleted flashcards in their non-deleted boxes';
comment on policy "Users can soft delete flashcards in their boxes" on public.flashcards is 'Users can only soft delete flashcards in their non-deleted boxes';

-- rls policies for box_tags
create policy "Users can view tags for their boxes"
  on public.box_tags for select
  using (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.box_tags.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    )
  );

create policy "Users can add tags to their boxes"
  on public.box_tags for insert
  with check (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.box_tags.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    )
  );

create policy "Users can delete tags from their boxes"
  on public.box_tags for delete
  using (
    exists (
      select 1 from public.boxes
      where public.boxes.id = public.box_tags.box_id
      and public.boxes.user_id = auth.uid()
      and public.boxes.is_deleted = false
    )
  );

comment on policy "Users can view tags for their boxes" on public.box_tags is 'Users can view tags for their non-deleted boxes';
comment on policy "Users can add tags to their boxes" on public.box_tags is 'Users can add tags to their non-deleted boxes';
comment on policy "Users can delete tags from their boxes" on public.box_tags is 'Users can remove tags from their non-deleted boxes';

-- rls policies for tags
create policy "Anyone can view tags"
  on public.tags for select
  using (true);

create policy "Anyone can insert tags"
  on public.tags for insert
  with check (true);

comment on policy "Anyone can view tags" on public.tags is 'Tags are globally visible to all users';
comment on policy "Anyone can insert tags" on public.tags is 'Any user can create new tags';

-- rls policies for generation_log
create policy "Users can view their generation logs"
  on public.generation_log for select
  using (auth.uid() = user_id);

create policy "Users can create their generation logs"
  on public.generation_log for insert
  with check (auth.uid() = user_id);

comment on policy "Users can view their generation logs" on public.generation_log is 'Users can view only their own generation logs';
comment on policy "Users can create their generation logs" on public.generation_log is 'Users can create generation logs only for themselves';

-- grant permissions to authenticated and anon users
grant usage on schema public to authenticated, anon;
grant select on all tables in schema public to authenticated, anon;
grant insert, update, delete on public.boxes, public.flashcards, public.box_tags, public.tags, public.generation_log to authenticated;

-- Set up default triggers for updated_at timestamps
create or replace function trigger_set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

comment on function trigger_set_updated_at() is 'Trigger function to automatically update the updated_at column';

create trigger set_updated_at
before update on public.boxes
for each row execute function trigger_set_updated_at();

create trigger set_updated_at
before update on public.flashcards
for each row execute function trigger_set_updated_at(); 